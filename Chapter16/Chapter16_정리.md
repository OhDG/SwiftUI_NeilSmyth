# 16_SwiftUI 개요

## 16.1_UIKit과 인터페이스 빌더

### 소프트웨어 개발 키트

SwiftUI 도입 이전에는 iOS 소프트웨어 개발 키트(software development kit, SDK)를 구성하는 여러 프레임워크와 함께 UIKit을 이용하여 iOS 앱을 만들었다.

### 인터페이스 빌더

앱 화면을 구성하는 사용자 인터페이스 레이아웃을 설계할 수 있도록 Xcode에는 인터페이스 빌더(interface builder)라는 도구가 포함되어 있다.

한 화면을 구성하는 사용자 인터페이스 레이아웃은 인터페이스 빌더 안에서 구축되며, 라이브러리 패널에서 버튼, 레이블, 텍스트 필드, 슬라이더 등의 컴포넌트를 드래그하여 화면 캔버스의 원하는 위치에 두는 식이었다.

### 인스펙터 패널

화면에 배치한 컴포넌트를 선택하면 인스펙터 패널(inspector panel)을 통해 컴포넌트의 속성을 바꿀 수도 있다.

### 컨스트레인트

화면의 레이아웃이 디바이스 화면 크기에 따라 어떻게 달라지는지, 그리고 디바이스의 방향(가로 모드/세로 모드)에 따라서는 어떻게 변하는지는 각 컴포넌트가 화면 크기와 다른 컴포넌트와의 관계에 따라 어느 크기로 어디에 둬야 하는지를 관장하는 컨스트레인트(constraint)로 결정된다.

---

## 16.2_SwiftUI의 선언적 구문

### 수정자

기본적으로 레이아웃에 포함될 컴포넌트들을 선언하고, 그것들이 포함될 레이아웃 매니저 종류(Vstack, Hstack, Form, List 등)를 명시하고, 속성(버튼의 텍스트, 레이블의 포그라운드 색상, 또는 탭 제스처 이벤트 시 호출될 메서드 등)을 설정하기 위하여 수정자(modifier)를 사용한다.

### 프리뷰 캔버스

뷰 레이아웃이 선언되고 테스트되는 동안 Xcode에서 제공하는 프리뷰 캔버스(preview canvas)를 통해 실시간으로 변경되는 레이아웃을 확인할 수 있다.

### 라이브 프리뷰

Xcode는 라이브 프리뷰 모드를 가지고 있어서 시뮬레이터나 디바이스에 빌드하고 실행하지 않아도 프리뷰 캔버스 내에서 앱을 실행하고 테스트할 수 있게 해준다.

---

## 16.3_SwiftUI는 데이터 주도적이다

### 바인딩

SwiftUI는 앱의 데이터 모델과 사용자 인터페이스 컴포넌트, 그리고 기능을 제공하는 로직을 바인딩(binding)하는 여러 방법으로 이러한 복잡도를 해결한다.

### 구독/게시

데이터 주도로 구현하면 데이터 모델은 앱의 다른 부분에서 구독(subscribe)할 수 있는 데이터 변수를 게시(publish)하게 된다. 이러한 방법을 통해 데이터가 변경되었다는 사실을 모든 구독자에게 자동으로 알릴 수 있다. 만약 사용자 인터페이스 컴포넌트와 데이터 모델 간에 바인딩이 된다면, 추가적인 코드를 작성하지 않아도 모든 데이터의 변경 사항을 SwiftUI가 사용자 인터페이스에 자동으로 반영할 것이다.

---

## 16.4_SwiftUI vs. UIKit

새로운 프로젝트에 SwiftUI를 쓰기로 했다고 해도 UIKit을 전혀 사용하지 않는 것은 아마도 불가능할 것이다. SwiftUI는 다양한 종류의 사용자 인터페이스 컴포넌트가 있지만, 지도라든가 웹 뷰를 통합해야 하는 식의 특정 기능은 여전히 UIKit을 사용해야 한다.

게다가, 매우 복잡한 사용자 인터페이스 레이아웃을 설계하는 경우에 SwiftUI 레이아웃 컨테이너 뷰 사용이 반족스럽지 않는 상황에서는 인터페이스 빌더를 사용해야 할 수도 있다.

---

## 16.5\_요약

SwiftUI는 사용자 인터페이스의 렌더링을 직접적으로 구현하는 방식이 아니라, 선언적 구문으로 사용자 인터페이스를 선언하고 앱이 실행될 때 렌더링을 수행하는 최선의 방법을 결정하기 위한 모든 작업을 한다.

### 게시자/구독자

SwiftUI는 데이터의 변화가 앱의 동작과 모양을 주도한다는 점에서 데이터 주도적이다. 이것은 게시자(publisher)와 구독자(subscriber) 모델을 통해 이뤄진다.
